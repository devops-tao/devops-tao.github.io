<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python函数（二）]]></title>
    <url>%2F2019%2F05%2F17%2FPython%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[参数解构 给函数提供实参的时候，可以在集合类型前使用或*，把集合类型的结构解开，提取出所有元素作为函数的实参 非字典类型使用*解构成位置参数 字典类型使用**解构成关键字参数 提取出来的元素数目要和参数的要求匹配，也要和参数的类型匹配 函数嵌套 在一个函数中定义另外一个函数 函数有可见范围，就是所谓的作用域 内部函数不能被外部函数直接使用，否则会抛NameError异常 In [24]: def outer(): ...: def inner(): ...: print(&apos;inner&apos;) ...: print(&apos;outer&apos;) ...: inner() In [25]: outer() outer inner In [27]: inner() --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-27-bc10f1654870&gt; in &lt;module&gt; ----&gt; 1 inner() NameError: name &apos;inner&apos; is not defined 作用域 一个标识符的可见范围，就是标识符的作用域，一般常说的是变量的作用域 局部作用域 在函数、类等内部可见 局部变量使用范围不能超过其所在的局部作用域 嵌套结构 def outer1(): | def outer2(): o = 65 | o = 65 def inner(): | def inner(): print(&quot;inner{}&quot;.format(o)) | o = 97 print(chr(o)) | print(&quot;inner{}&quot;.format(o)) print(&quot;outer{}&quot;.format(o)) | print(chr(o)) inner() | print(&quot;outer{}&quot;.format(o)) outer1() | inner() | outer2() 从上例中可以看出： 外层变量作用域在内层作用域可见 内层作用域inner中，如果定义了o = 97 ，相当于当前作用域中重新定义了一个新的变量o，但是这个o并没有覆盖外层作用域outer中的o 再看一个简单的例子 代码： x = 5 def foo(): x += 1 x += 1 其实就是 x = x + 1，相当于在foo内部定义一个局部变量x，那么foo内部所有x都是这个局部变量x了，但是这个x还没有完成赋值，就被右边拿来做加1操作了，所以调用该函数时会抛出异常（UnboundLocalError: local variable ‘x’ referenced before assignment），想要解决这个问题，就得使用全局变量global了 全局作用域 在整个程序的运行环境中可见 全局变量global 实例1中，使用global关键字的变量，将foo内的x声明为外部的全局作用域中的定义x 全局作用域中必须有x的定义 代码实例1： x = 5 def foo(): global x x += 1 实例2中，使用global关键字的变量，将foo内的x声明为外部的全局作用域中的定义x 但是，x = 10 赋值及定义，x在内部作用域为一个外部作用域的变量赋值，所有x += 1 不会报错，注意，这里的x的作用域还是全局的（针对该函数而言） 代码实例2： def foo(): global x #该变量的全局是相对于foo函数而言的 x = 10 #赋值及定义 x += 1 #不会报错 print(x) #打印出11 print(x) #报错，因为在程序运行环境全局中没有定义‘x’ global总结 x += 1这种是特殊形式长生的错误的原因？先引用后赋值，而python动态语言是赋值才算定义，才能被引用。解决方法，在这条语句之间增加 x=0 之类的赋值语句，货真使用global告诉内部作用域，取全局作用域查找变量定义 内部作用域使用 x=5 之类的赋值语句会重新定义局部作用域中使用的变量x，但是，一旦这个作用域使用global声明x为全局的，那么 x=5 相当于在位全局作用域的变量x赋值 global使用规则 外部作用域变量在内部作用域可见，但也不要在这个内部的局部作用域中直接使用，因为函数的母的就是为了封装，尽量与外界隔离 如果函数需要使用外部全局变量，请使用函数的形参传参解决 一句话，不适用global，学习它只是为了深入理解变量作用域 闭包 自由变量：未在本地作用于中定义的变量，例如定义在内层函数外的外层函数的作用域中的变量 闭包：就是一个概念，出现在嵌套函数中，值得是 内层函数引用到了外层函数的自由变量 ，就形成了闭包。 代码实例解析 def counter(): c = [0] def inc(): c[0] += 1 #不会报错，c在counter函数中固定义过了，而且inc中的使用方式是为c的元素修改值，而不是重新定义变量 return c[0] return inc foo = counter() print(foo(),foo()) #打印 1 2 c = 100 # 这个c和counter中的c死不一样的，而inc引用的是自由变量也就是counter中的变量c print(foo()) #打印3 上例是Python2中实现闭包的方式,Python3还可以使用nonlocal关键字]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数（一）]]></title>
    <url>%2F2019%2F05%2F17%2FPython%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[函数 函数 数学定义：y=f(x)，y是x的函数，x是自变量 Python函数 由若干个语句组成的语句块、函数名称、参数列表构成，它是组织代码的最小单元 完成一定的功能 函数的作用 结构化变成对代码的最基本的封装，一般按照功能组织一段代码 封装的目的是为了复用，减少冗余 代码更加简洁美观、可读易懂 函数的分类 内建函数，如max()、reversed()等 库函数，如math.ceil()等 函数定义、调用 def语句定义函数 def 函数名(参数列表)： 函数体(代码块) [return 返回值] 函数名就是标识符，命名要求一样 语句块必须缩进，约定4个空格 Python的函数没有return语句时，隐式会返回一个None值 定义中的参数列表成为形式参数，只是一种符号表达，简称形参 调用 函数定义只是声明了一个函数，它不会被执行，需要调用 调用的方式，就是函数名加上小括号，括号内写上参数 调用时写的参数是实际参数，是实实在在传入的值，简称实参 函数举例 In [1]: def add(x,y): #定义一个add函数 ...: result = x + y ...: return result In [2]: out = add(4,5) #调用add函数 In [3]: print(out) 9 注意：1、函数是可调用对象，callable() 2、函数需要在调用前定义，否则会抛NameError异常 函数参数 参数调用时传用的参数要和定义的个数相匹配（可变参数除外） 参数默认值 def fn(x=5): print(x) fn() #等价于fn(x=5) 位置参数 按照参数定义顺序传入实参 def f(x,y,z) 调用使用 f(1,3,5) 关键字参数 使用形参的名字来传入实参的方式，如果使用了形参名字，那么传参顺序就可和定义顺序不同 def f(x,y,z) 调用使用 d(x=1,z=5，y=3) 可变参数 一个形参可以匹配任意个参数 位置参数的可变参数 在形参前使用*表示该形参是可变参数，可以接受多个实参 收集多个实参为一个tuple 有多个数，需要累加求和 In [7]: def add(*nums): #*nums为可变参数 ...: sum = 0 ...: print(type(nums)) #打印参数类型 ...: for x in nums: ...: sum += x ...: print(sum) In [8]: add(3,6,9) #调用函数add &lt;class &apos;tuple&apos;&gt; 18 关键字参数的可变参数 在形参前使用**符号，表示可以接收多个关键字参数 收集的实参名称和值组成一个字典 打印配置信息： In [9]: def showconfig(**kwargs): ...: for k,v in kwargs.items(): ...: print(&apos;{}:{}&apos;.format(k,v)) In [10]: showconfig(host=&apos;127.0.0.1&apos;,port=&apos;4000&apos;,username=&apos;tao&apos;,password=&apos;123456&apos;) password:123456 username:tao port:4000 host:127.0.0.1 可变参数混合使用 配置信息打印 def showconfig(username,password,**kwargs) def showconfig(username,args,*kwargs) def showconfig(username,password,*kwargs,args) 总结 可变参数分为位置可变参数和关键字可变参数 位置可变参数在形参前面使用一个星号* 关键字可变参数在形参面前使用两个星号** 位置可变参数和关键字可变参数都可以收集若干个实参，位置可变参数收集形成一个tuple，关键字可变参数收集形成一个dict 混合使用参数时，可变参数要放到参数列表的最后，普通参数需要放到参数列表前面，位置可变参数需要在关键字可变参数之前 keyword-only参数（Python3加入） 如果在一个星号参数后，或者一个位置可变参数后，出现的普通参数，实际上已经不是普通参数了，而是keyword-only参数 In [12]: def fn(*args,x): ...: print(x) ...: print(args) In [13]: fn(3,5,x=7) 7 (3, 5) args可以看作已经截获了所有的位置参数，x如果不使用关键字参数就不可能拿到实参 keyword-only参数另一种形式 In [20]: def fn(*,x,y): ...: print(x,y) In [21]: fn(x=1,y=2) 1 2 *号之后，普通形参都变成了必须给出的keyword-only参数 函数参数总结 参数规则 参数列表参数的一般顺序是，普通参数，缺省参数，位置可变参数，keyword-only参数（带缺省值），关键字可变参数 def fn(x,y,z=3,args,m=3,n,*kwargs): print(x,y,z,m,n) print(args) print(kwargs)]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python相关知识点（一）]]></title>
    <url>%2F2019%2F05%2F16%2FPython%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[线性结构 线性结构 可迭代 for … in 可用len()获取长度 可以通过下标访问 可以切片 学过的线性结构 列表、元组、字符串、bytes、bytearray 切片 切片 通过索引区间访问线性结构的一段数据 sequence[start,stop]区间的子序列 支持负索引 start为0，可以省略 stop为末尾，可以省略 超过上界（有边界），就取到末尾；超过下界（左边界），取到开头 start一定要在stop左边 [:] 表示从头至尾，全部元素取出，等效于copy()方法 步长切片 [start:stop:step] step为不长，可正、负整数，默认是1 setp要和start:stop同向，否则返回空序列 In [1]: ‘www.hongtao.com’[4:10:2] #setp和start:stop同向Out[1]: ‘hnt’In [2]: list(‘www.hongtao.com’)[4:10:-2] #setp和start:stop不同向Out[2]: [] 封装和解构 例子 a = 3In [4]: b = 4In [5]: temp = a &lt;==&gt; a,b=b,aIn [6]: a = bIn [7]: b = temp 上例a,b = b,a中，等号右边使用了封装，而左边则是使用了解构 解构 把线性结构的元素解开，并顺序的赋给其它变量 左边接纳的变量数要和右边解开的元素个数一致 In [8]: lst = [1,2]In [9]: first,second = lstIn [10]: print(first,second)1 2#非线性结构也可以结构：In [12]: a,b = {‘a’:1,’b’:2}In [13]: aOut[13]: ‘a’In [14]: bOut[14]: ‘b’ Python3的解构 使用 *变量名 接收，但不能单独使用 被 *变量名 收集后组成一个列表 In [15]: lst = list(range(1,11,2))In [16]: head,*mid,tail = lstIn [17]: type(mid)Out[17]: list #mid类型为list 丢弃变量 在python中，如果不关心一个变量，可以定义改变量的名字为_，这是一个惯例，一个不成文的约定，而不是标准 _是一个合法的标识符，也可以作为一个一个有效的变量使用，但是定义成下划线就是希望不被使用，除非你明确的知道这个数据需要使用，否则不推荐 In [18]: lst = list(range(1,11,2))In [19]: head,*_,tail = lstIn [20]: print(_) #_是一个合法的标识符，看到下划线就知道该变量不想被使用[3, 5, 7] 总结 _这个变量本身无任何语义，没有任何可读性，所以不是用来给人使用的 Python中很多库都在使用这个变量，使用十分广泛，故在不明确变量作用域的情况下，不推荐使用_变量，避免和库中_冲突 集合基本概念 全集：所有元素的集合，例如实数集，所有实数组成的集合就是全集 子集(subset)和超集(superset)：一个集合A所有元素在另外一个集合B内，A是B的子集，B是A的超集 真子集和真超集：A是B的子集，且A不等于B，A就是B的真子集，B是A的真超集 并集：多个集合合并的结果 交集：多个集合的公共部分 差集：集合中除去和其他集合公共部分 集合运算 并集 将两个集合A和B的所有的元素合并到一起，组成的集合称作集合A与集合B的并集 union(*others) –&gt; 返回多个集合合并后的新的集合 | 运算符重载（等同union） update(*others) –&gt; 和多个集合合并，就地修改 |= （等同与update） 交集 集合A和B，由所有属于A且属于B的元素组成的集合 intersection(*others) –&gt; 返回和多个集合的交集 &amp; （等同intersection） intersection_uodate(*others) –&gt; 获取和多个集合的交集，并就地修改 &amp;= （等同intersection_uodate） 差集 集合A和B，由所有属于A且不属于B的元素组成的集合 difference(*others) –&gt; 返回会多个集合的差集 - （等同difference） difference_update(*others) –&gt; 获取和多个集合的差集并就地修改 -= （等同difference_update） 对称差集 集合A和B，由所有不属于A和B的交集元素组成的集合，记作（A-B）∪(B-A) symmetric_differece(other) –&gt; 返回和另一个集合的差集 ^ （等同symmetric_differece） symmetric_differece_update(other) –&gt; 获取和另一个集合的差集并就地修改 ^= (等同symmetric_differece_update) issubset、&lt;= –&gt; 判断当前集合是否是另一个集合的自己 set1 &lt; set2 –&gt; 判断set1是否是set2的真子集 issuperset(other)、&gt;= –&gt; 判断当前集合是否是other的超集 set1 &gt; set2 –&gt; 判断set1是否是set2的真超集 isdisjoint(other) –&gt; 判断当前集合与另一集合是否有交集，没有交集，返回True 列表解析List Comprehension 语法 [返回值 for 元素 in 可迭代对象 if 条件] 使用中括号[],内部是for循环，if条件语句可选 返回一个新的列表 列表解析是一种语法糖 编译器会优化，不会因为简写而影响效率，反而因优化提高了效率 减少程序员工作量，减少出错 简化了代码，增强了可读性 列表解析进阶 [expr for in iterable1 for j in iterable2] In [2]: [(x,y) for x in ‘abcde’ for y in range(3)] Out[2]: [(‘a’, 0),(‘a’, 1),(‘a’, 2),(‘b’, 0),(‘b’, 1),(‘b’, 2),(‘c’, 0),(‘c’, 1),(‘c’, 2),(‘d’, 0),(‘d’, 1),(‘d’, 2),(‘e’, 0),(‘e’, 1),(‘e’, 2)] 迭代器 特殊的对象，一定是可迭代对象，具备可迭代对象的特征 通过iter方法把一个可迭代对象封装成迭代器 通过next方法，迭代迭代器对象 生成器对象，就是迭代器对象 生成器 可迭代对象 迭代器 生成器表达式Generrator expression 语法 (返回值 for 元素 in 可迭代对象 if 条件) 返回一个生成器 和列表解析式的对比 计算方式 生成器表达式是按需计算(或称惰性求值、延迟计算)，需要的时候才计算值，列表解析式立即计算，然后返回新的列表 内存占用 单从返回值本身来说，生成器表达式省内存 生成器没有数据，内存占用极少，但是使用的时候，虽然一个个返回数据，但是合起来占用的内存跟列表解析式差不多 列表解析式构用新的列表占用内存 计算速度 单看计算时间，生成器表达式耗时非常短，列表解析式耗时长 生成器本身并没有返回任何值，只返回了一个生成器对象 列表解析式构造并返回了新的列表]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基本内置数据结构（二）]]></title>
    <url>%2F2019%2F05%2F16%2Fpython%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在Python3中，引入了两个新类型：bytes（不可变字节序列）、bytearray（可变、字节数组） bytes、bytearraybytesbytes定义定义 bytes() –&gt; 空bytes bytes(int) –&gt; 指定字节的bytes，被0填充 bytes(iterable_of_ints) –&gt; bytes[0,255]的int可迭代对象 bytes(string,encoding[,errors]) –&gt; bytes等价于string.encode() bytes(bbytes_or_buffer) –&gt; immutable copy of bbytes_or_buffer 从一个字节序列或者buffer复制出一个新的不可变的bytes对象 使用b前缀定义 只允许基本ASCII使用字符形式b’abc9’ 使用16进制表示b”\x41\x61” bytes操作 和str类型类似，都是不可变类型，所以很多方法都一样，只不过bytes的方法，输出的是bytes，输出的也是bytes In [1]: b’abcdef’.replace(b’f’,b’k’)Out[1]: b’abcdek’In [2]: b’abc’.find(b’b’)Out[2]: 1 类方法 bytes.fromhex(string) string必须是2个字符的16进制的形式，’6162 6a 6b’，空格将被忽略 In [3]: bytes.fromhex(‘6162 09 6a 6b00’)Out[3]: b’ab\tjk\x00’In [4]: bytes.fromhex(‘6162 6a 6b’)Out[4]: b’abjk’ hex() 返回16进制表示的字符串 In [5]: ‘abc’.encode().hex()Out[5]: ‘616263’ 索引 返回对应该字节的数，int类型 In [6]: b’abcdef’[2]Out[6]: 99 bytearraybytearray定义定义 bytearray() –&gt; 空bytes bytearray(int) –&gt; 指定字节的bytes,被0填充 bytearray(iterable_of_ints) –&gt; bytes[0,255]的int组成的可迭代对象 bytearray(string,encode[,errors]) –&gt; bytes 近似string.encode(),不过返回可变对象 bytearray(bbytes_or_buffer) –&gt; 从一个字节序列的buffer复制出一个新的可变对象的bytearray对象 注意，b前缀定义的类型时bytes类型，而不是bytearray bytearray操作 和bytes类型的方法相同 In [7]: bytearray(b’abcdef’).replace(b’c’,b’e’)Out[7]: bytearray(b’abedef’) 类方法 bytearray.fromhex(string) string必须是2个字符的16进制的形式，’6162 6a 6b’，空格将被忽略 In [8]: bytearray.fromhex(‘6162 6a 6b’)Out[8]: bytearray(b’abjk’) hex() 返回16进制表示的字符串 In [9]: bytearray(‘abc’.encode()).hex()Out[9]: ‘616263’ 索引 返回该字节对那个的数，int类型 In [10]: bytearray(b’abcdef’)[3]Out[10]: 100 append(int) –&gt; 尾部追加一个元素 insert(index,int) –&gt; 在指定索引位置插入元素 extend(iterable_of_ints) –&gt; 将一个可迭代的整数集合追加到当前的bytearray pop(index=-1) –&gt; 从指定索引上移除元素，默认从尾部移除 remove(value) –&gt; 从左至右，找到第一个value，找不到抛ValueError异常 注意，使用该方法需要使用int类型，value在[0,255] clear() –&gt; 清空bytearray reverse() –&gt; 翻转bytearray，就地修改 字符串与bytes、bytearray 字符串是字符组成的有序序列，字符可以使用编码来理解 bytes是字节组成的有序的不可变序列 bytearray是字节组成的有序的可变序列 编码与解码 字符串按照不哦那个的字符集编码encode返回字节序列bytes encode(encoding = ‘utf-8’,errors = ‘strict’) –&gt; bytes 字节序列按照不同的祖父姐解码decode返回字符串 bytes.decode(encoding=”utf-8”,errors=”strict”) –&gt; str bytearray.decode(encoding=”utf-8”,errors=”strict”) –&gt; str]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基本内置数据结构（一）]]></title>
    <url>%2F2019%2F05%2F12%2FPython%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数值型数值型 int、float、complex、bool都是class，1，2.0，3+4j都是对象即实例 int：python3中的int就是长整型，且没有大小限制，受限于内存区域的大小 float：由整数部分和小数部分组成。支持十进制和科学计数法表示，只有双精度型 complex：由实数和虚数部分组成，实数和虚数部分都是浮点数，如3+4.5j bool：int的子类，仅有2个实例True、False对应1和0，可以和证书直接运算 类型转换( built-in ) int(x) 返回一个整数 float(x) 返回一个浮点数 complex(x)、complex(x,y)返回一个复数 bool(x)返回布尔值 tip：float不能精确的表示一个小数，只能近似表达，如3.333….. 故float数不建议比较是否相等，建议比较大小 序列对象字符串(str) 一个个字符组成的有序的序列，是字符的集合 使用单引号、双引号、三引号引住的字符序列 字符是不可变对象 Python中、字符串是Unicode类型字符串元素访问——下标 字符串支持使用索引访问 In [1]: sql=&quot;select * from user where name=&apos;zht&apos;&quot; In [2]: sql[4] Out[2]: &apos;c&apos; 有续费字符集合，字符序列 for c in sql: print(c) #依次返回s、e、l、e、....、h、t、&apos; print(type(c)) #返回&lt;class &apos;str&apos;&gt;，说明c是字符串 可迭代 In [1]: sql = &quot;select&quot; In [2]: lst = list(sql) In [3]: lst Out[3]: [&apos;s&apos;, &apos;e&apos;, &apos;l&apos;, &apos;e&apos;, &apos;c&apos;, &apos;t&apos;] 字符串连接（join） “string”.join(iterable) -&gt; str 将可迭代对象连接起来，使用string作为分隔符 可迭代对象本身都是字符串 返回一个新字符串 In [1]: lst = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;] In [2]: print(&quot;\&quot;&quot;.join(lst)) 1&quot;2&quot;3 In [3]: print(&quot; &quot;.join(lst)) 1 2 3 In [4]: print(&quot;\n&quot;.join(lst)) 1 2 3 字符串连接（+） + -&gt; str 将2个字符串连接再一起 返回一个新的字符串 In [7]: a = &apos;abc&apos; In [8]: b = &apos;def&apos; In [9]: a+b Out[9]: &apos;abcdef&apos; 字符串分割 split(sep=None,maxsplit=-1) -&gt; list of strings （常用） 将字符串按照分隔符分割成若干字符串，并返回列表 从左到右 sep指定分割字符串，缺省的情况下空白字符串作为分隔符 maxsplit制定分割的次数，-1表示遍历整个字符串 In [10]: s1 = &quot;I&apos;m \ta super student.&quot; In [11]: s1.split() Out[11]: [&quot;I&apos;m&quot;, &apos;a&apos;, &apos;super&apos;, &apos;student.&apos;] In [12]: s1.split(&apos;s&apos;) Out[12]: [&quot;I&apos;m \ta &quot;, &apos;uper &apos;, &apos;tudent.&apos;] In [13]: s1.split(&apos;super&apos;) Out[13]: [&quot;I&apos;m \ta &quot;, &apos; student.&apos;] In [14]: s1.split(&apos;super &apos;) Out[14]: [&quot;I&apos;m \ta &quot;, &apos;student.&apos;] In [15]: s1.split(&apos; &apos;) Out[15]: [&quot;I&apos;m&quot;, &apos;\ta&apos;, &apos;super&apos;, &apos;student.&apos;] In [16]: s1.split(&apos; &apos;,maxsplit=2) Out[16]: [&quot;I&apos;m&quot;, &apos;\ta&apos;, &apos;super student.&apos;] In [17]: s1.split(&apos;\t&apos;,maxsplit=2) Out[17]: [&quot;I&apos;m &quot;, &apos;a super student.&apos;] rsplit(sep=None,maxsplit=-1) -&gt; list of strings （常用） 从右到左 sep指定分割字符串，缺省的情况下空白字符串作为分隔符 maxsplit制定分割的次数，-1表示遍历整个字符串 splitlines([keepends]) -&gt; list of strings 按照行来切分字符串 keepends指的是是否包就行分隔符 行分隔符包括\n、\r\n、\r等 In [27]: &apos;ab c\n\nde fg\rkl\r\n&apos;.splitlines() Out[27]: [&apos;ab c&apos;, &apos;&apos;, &apos;de fg&apos;, &apos;kl&apos;] In [28]: &apos;ab c\n\nde fg\rkl\r\n&apos;.splitlines(True) Out[28]: [&apos;ab c\n&apos;, &apos;\n&apos;, &apos;de fg\r&apos;, &apos;kl\r\n&apos;] partition(sep) -&gt; (head,sep,tail) 从左至右，遇到分隔符就把字符串分割成两部分，返回头、分隔符、尾三部分；如果没有找到分隔符，就返回头、2个空元素的三元组 sep分割字符串，必须指定 In [21]: s2 = &quot;I&apos;m a super student.&quot; In [22]: s2.partition(&apos;s&apos;) Out[22]: (&quot;I&apos;m a &quot;, &apos;s&apos;, &apos;uper student.&apos;) In [23]: s2.partition(&apos;stu&apos;) Out[23]: (&quot;I&apos;m a super &quot;, &apos;stu&apos;, &apos;dent.&apos;) In [24]: s2.partition(&apos; &apos;) Out[24]: (&quot;I&apos;m&quot;, &apos; &apos;, &apos;a super student.&apos;) In [25]: s2.partition(&apos;abc&apos;) Out[25]: (&quot;I&apos;m a super student.&quot;, &apos;&apos;, &apos;&apos;) rpartition(sep) -&gt; (head,sep,tail) 从右至左，遇到分隔符就把字符串分割成两部分，返回头、分隔符、尾三部分；如果没有找到分隔符，就返回头、2个空元素的三元组 字符串大小写 upper() #全大写 lower() #全小写 swapcase() #交互大小写 字符串排版 title() -&gt; str #标题的每个单词都大写 capitalize() -&gt; str #首个单词大写 center(width[,fillchar]) -&gt; str #width打印宽度、fillchar填充的字符 zfill(width) -&gt; str #width打印宽度，居右，左边用0填充 ljust(width[,fillchar]) -&gt; str左对齐 rjust(width[,fillchar]) -&gt; str右对齐 字符串修改 replace(old,new[,count]) -&gt; str 字符串中找到平日配替换为新子串，返回新字符串 count表示替换几次，不指定就是全部替换 In [1]: &apos;www.tao.com&apos;.replace(&apos;w&apos;,&apos;p&apos;) Out[1]: &apos;ppp.tao.com&apos; In [2]: &apos;www.tao.com&apos;.replace(&apos;w&apos;,&apos;p&apos;,2) Out[2]: &apos;ppw.tao.com&apos; In [3]: &apos;www.tao.com&apos;.replace(&apos;w&apos;,&apos;p&apos;,3) Out[3]: &apos;ppp.tao.com&apos; In [4]: &apos;www.tao.com&apos;.replace(&apos;ww&apos;,&apos;p&apos;,2) Out[4]: &apos;pw.tao.com&apos; In [5]: &apos;www.tao.com&apos;.replace(&apos;www&apos;,&apos;python&apos;,2) Out[5]: &apos;python.tao.com&apos; strip([chars]) -&gt; str 从字符串两端去除制定的字符集chars中的所有字符 如果chats没有制定，去除两端的空白字符 In [6]: s = &quot;\r\n\t Hello Python \n \t&quot; In [7]: s Out[7]: &apos;\r\n\t Hello Python \n \t&apos; In [8]: s.strip() Out[8]: &apos;Hello Python&apos; In [9]: s = &quot;I am very very very sorry &quot; In [10]: s Out[10]: &apos;I am very very very sorry &apos; In [11]: s.strip(&apos;Iy&apos;) Out[11]: &apos; am very very very sorry &apos; In [12]: s.strip(&apos;Iy &apos;) Out[12]: &apos;am very very very sorr&apos; lstrip([chars]) -&gt; str #从左开始 rstrip([chars]) -&gt; str #从右开始 字符串查找 find(sub[,start[,end]]) -&gt; int 在指定的区间[start,end),从左至右，查找子串sub，找到返回索引，没找到返回-1 In [21]: s Out[21]: &apos;I am very very very sorry &apos; In [22]: s.find(&apos;very&apos;) Out[22]: 5 In [23]: s.find(&apos;very&apos;,5) Out[23]: 5 In [24]: s.find(&apos;very&apos;,6,13) Out[24]: -1 rfind(sub[,start[,end]]) -&gt; int 在指定的区间[start,end),从右至左，查找子串sub，找到返回索引，没找到返回-1 In [25]: s.rfind(&apos;very&apos;,10) Out[25]: 15 In [26]: s.rfind(&apos;very&apos;,10,15) Out[26]: 10 In [27]: s.rfind(&apos;very&apos;,-10,-1) Out[27]: -1 index(sub[,start[,end]]) -&gt; int 在指定的区间[start,end)，从左至右，查找子串sub。找到返回索引，没找到抛出异常ValueError rindex(sub[,start[,end]]) -&gt; int 在指定的区间[start,end)，从右至左，查找子串sub。找到返回索引，没找到抛出异常ValueError count(sub[,start[,end]]) -&gt; int 在指定的区间[start,end)，从左至右，统计子串sub出现的次数 In [28]: s.count(&apos;very&apos;) Out[28]: 3 In [29]: s.count(&apos;very&apos;,5) Out[29]: 3 In [30]: s.count(&apos;very&apos;,10,14) Out[30]: 1 tip：index和count方法时间复杂度都是O(n)，效率随着列表数据的 增大而下降,建议少用 len(string) #返回字符串的长度，即字符的个数 字符串判断 endswith(suffix[,start[,end]]) -&gt; bool 判断在指定的区间[start,end),字符串是都是suffix结尾 startswith(prefix[,start[,end]]) -&gt; bool 判断在指定的区间[start,end),字符串是都是prefix结尾 字符串判断is系列 isalnum() -&gt; bool #判断是否是i字母和数字组成 iisalpha() #判断是否是字母 isdecimal() #判断是否只包含十进制数字 isdigit() #判断是否是数字(0~9) islower() #判断是否都是小写 isupper() #判断是否都是大写 isspace() #判断是否只包含空白字符 isidentifier() #判断是否是字母和下划线开头,其他都是字母、数字、下划线 字符串格式化 字符串的格式化是一种拼接字符串输出样式的手段，更灵活方便 join拼接只等使用分隔符，且要求被拼接的是可迭代对象 拼接字符串还算方便，但是非字符串需要先转换为字符串才能拼接 在2.5版本之前，只能使用ptintf style枫阁的print输出（了解即可） printf-style formatting，来自C语言的printf函数 格式要求 占位符：使用%和格式字符组成，例如%s，%d等 s调用str()，r调用repr()。所有对象都可以被这两个转换 占位符中还可以插入修饰字符，例如%03d表示打印3个位置，不够前面补零 format % values，格式字符串和被格式的值之间使用%分割 values只能是一个对象，或是一个和字符串占位符数目相等的元组，或一个字典 format函数格式字符串语法（Python中推荐使用） “{} {xxx}”.format(*agrs,**kwargs) -&gt; str args是位置参数，是一个元组 kwargs是关键字参数，是一个字典 花括号表示占位符 {}表示按照顺序匹配直至参数，{n}表示取位置参数索引为n的值 {xxx}表示在关键字参数中搜索名称一致的 位置参数 “”{}:{}”.format(‘172.16.120.8’,8888)”这就是按照位置顺序用位置参数替换前面的格式字符串的占位符中 In [31]: &quot;{}:{}&quot;.format(&apos;172.16.120.8&apos;,8888) Out[31]: &apos;172.16.120.8:8888&apos; 关键字参数或命名参数 “{server} {1}:{0}”.form(8888,’172.16.120.8’,server=’Web Server Info:’),位置 参数按照序号匹配，关键字参数按照名词匹配 In [32]: &quot;{server} {1}:{0}&quot;.format(8888,&apos;172.16.120.8&apos;,server=&apos;Web Server Info:&apos;) Out[32]: &apos;Web Server Info: 172.16.120.8:8888&apos; 访问元素 In [35]: &quot;{0[0]}.{0[1]}&quot;.format((&apos;tao&apos;,&apos;com&apos;)) Out[35]: &apos;tao.com&apos; 对象属性访问 In [39]: from collections import namedtuple In [40]: Point = namedtuple(&apos;Point&apos;,&apos;x y&apos;) In [41]: p = Point(4,5) In [42]: &quot;{{{0.x},{0.y}}}&quot;.format(p) Out[42]: &apos;{4,5}&apos; 对齐 In [43]: &apos;{0}*{1}={2:&lt;2}&apos;.format(3,2,2*3) Out[43]: &apos;3*2=6 &apos; In [44]: &apos;{0}*{1}={2:&lt;02}&apos;.format(3,2,2*3) Out[44]: &apos;3*2=60&apos; In [45]: &apos;{0}*{1}={2:&gt;02}&apos;.format(3,2,2*3) Out[45]: &apos;3*2=06&apos; In [46]: &apos;{:^10}&apos;.format(&apos;centered&apos;) Out[46]: &apos; centered &apos; In [47]: &apos;{:*^10}&apos;.format(&apos;centered&apos;) Out[47]: &apos;*centered*&apos; 进制 In [48]: &quot;int:{0:d}; hex:{0:x}; oct:{0:o}；bin:{0:b}&quot;.format(42) Out[48]: &apos;int:42; hex:2a; oct:52；bin:101010&apos; In [49]: &quot;int:{0:d}; hex:{0:#x}; oct:{0:#o}；bin:{0:#b}&quot;.format(42) Out[49]: &apos;int:42; hex:0x2a; oct:0o52；bin:0b101010&apos; In [51]: octets = [172,16,1,1] In [52]: &apos;{:02X}{:02X}{:02X}{:02X}&apos;.format(*octets) Out[52]: &apos;AC100101&apos; 列表(list) 一个队列，一个排列整齐的队伍 列表内的个体称作元素，有若干元素组成列表 元素可以说任意对象（数字、字符串、对象、列表等） 列表内元素有顺序，可以用索引 列表是线性的数据结构 使用[]表示 列表是可变的 列表list定义 初始化 list() -&gt; new empty list list(iterable) -&gt; new list initialized from iterables’s items 列表一开始不能定义大小 In [1]: lst = list() In [2]: print(type(lst)) &lt;class &apos;list&apos;&gt; In [3]: lst1 = [] In [4]: print(type(lst1)) &lt;class &apos;list&apos;&gt; In [5]: lst1 Out[5]: [] In [6]: lst2 = [1,3,5,&apos;ab&apos;] In [7]: lst2 Out[7]: [1, 3, 5, &apos;ab&apos;] In [8]: lst3 = list(range(5)) In [9]: lst3 Out[9]: [0, 1, 2, 3, 4] 列表索引访问 list[index]，index就是索引，使用中括号访问 索引，也叫下标 正索引：从左至右，从0开始，为列表中每一个元素编号 负索引：从右至左，从-1开始 政府索引不可超界，否则引发异常IndexError 列表查询 index(value,[start,[stop]]) 通过值value，从制定区间查找列表内的元素是否匹配 匹配到第一个就立即返回索引 匹配不到，抛出异常ValueError count(value) 返回列表中匹配value的次数 列表元素修改 索引访问修改（索引不要超界) In [13]: lst Out[13]: [1, &apos;b&apos;, &apos;c&apos;] In [14]: lst[0] = &apos;a&apos; In [15]: lst Out[15]: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 列表增加、插入元素 append(object) -&gt; None 列表尾部追加元素，返回None 返回None就意味着没右新的列表产生，所以append()是就地修改 时间复杂度是O(1) insert(index,object) -&gt; None 在指定的索引index出插入元素object 返回None就意味着没右新的列表产生，所以insert()也是就地修改 时间复杂度是O(1) 索引超越上界，则尾部追加，超越下界，则头部追加 extend(iteratable) -&gt; None 将可迭代对象的元素追加进来，返回None 也是就地修改 + -&gt; list 连接操作，将两个列表连接起来 产生新的列表，原列表不变 本质上调用的是add()方法 -&gt; list 重复操作，将本列表的元素重复n此，返回新的列表 列表删除元素 remove(value) -&gt; None 从左至右查找第一个匹配value的值，移除该元素，返回None 就地修改 pop([index]) -&gt; item 不指定索引index，就从列表尾部弹出一个元素 指定索引index，就从索引出弹出一个元素，索引超界抛出IndexError错误 clear() -&gt; None 清除列表所有元素，只剩一个空列表 列表其他操作 reverse() -&gt; None 将列表元素反转，返回None 就地修改 sort(key=None,reverse=False) -&gt; None 对列表元素进行排序，就地修改，默认升序 reverse为True，反转，降序 key是一个函数，指定key如何排序 ist.sort(key=functionname) in 判断元素是否在列表中，返回bool In [1]: [3,4] in [1,2,[3,4]] Out[1]: True 列表复制 copy() -&gt; list shadow copy返回一个新的列表 影子拷贝，也叫浅拷贝，遇到引用类型，只是复制了一个引用而已 深拷贝 copy模块提供了deepcopy 元组(tuple) 一个有序的元素组成的集合 使用小括号()表示 元祖是不可变对象 元组的定义、初始化 定义 tuple() -&gt; empty tuple tuple(iterable) -&gt; initialized from iterable’s items In [19]: t = tuple() In [20]: print(type(t)) &lt;class &apos;tuple&apos;&gt; In [21]: t1 = () In [22]: print(type(t1)) &lt;class &apos;tuple&apos;&gt; In [23]: t2 = tuple(range(1,7,2)) In [24]: t2 Out[24]: (1, 3, 5) In [25]: print(type(t2)) &lt;class &apos;tuple&apos;&gt; In [26]: t = (1,) In [27]: t Out[27]: (1,) In [28]: print(type(t)) &lt;class &apos;tuple&apos;&gt; 元祖元素的访问 支持索引（下标） 正索引：从左至右，从0开始，为列表中每一个元素编号 负索引：从右至左，从-1开始 索引不可越界，否则引发异常IndexError 元组通过索引访问 tuple[index],index就是索引，使用中括号访问 元组查询 index(value,[start,[stop]]) 通过值value，从指定区间查找列表内的元素是否匹配 匹配到第一个就立即返回索引 匹配不到，则抛出异常ValueError conut(value) 返回 列表中匹配value的次数 tip：index和conut方法的时间复杂度都是O(n)，且效率随着元组数据 规模的增大而下降 len(tuple) 返回该元组元素的个数 元组的其他操作 元祖是只读的，所以没有增、删、改方法 命名元组 namedtumple(typename,field_names,verbose=False,rename=False) 命名元组，返回一个元组的子类，并定义了字段 field_nameds可以是空格或逗号分割的字段的字符段，可以是字符的列表 In [29]: from collections import namedtuple In [30]: Point = namedtuple(&apos;_Point&apos;,[&apos;x&apos;,&apos;y&apos;]) In [31]: p = Point(11,12) In [32]: p Out[32]: _Point(x=11, y=12) In [33]: Student = namedtuple(&apos;Student&apos;,&apos;name age&apos;) In [34]: tom = Student(&apos;tom&apos;,20) In [35]: tom.name Out[35]: &apos;tom&apos; 键值对集(set) 约定 set翻译为集合 collection翻译为集合类型，是一个大概念 set 可变的、无序的、不重复的元素的集合 set的元素 set的元素要求必须可以hash 目前学过的不可hash的类型哟list、set 元素不可以索引 set可以迭代 set的增加 add(elem) 增加一个元素到set中 如果元素存在，则什么都不做 update(*others) 合并其他元素到set集合中来 参数others必须是可迭代对象 就地修改 set删除 remove(elem) 从set中移除一个元素 元素不存在，抛出KeyError异常 discard（elem） 从set中移除一个元素 元素不存在，则什么都不做 pop() -&gt; item 移除并返回任意的元素 空集返回KeyError clear() 移除所有元素 set修改、查询 修改 要么删除、要么加入新的元素，没有修改 查询 非线性结构，无法索引 遍历 可以迭代所有元素 成员运算符 in 和 not in可判断元素是否在set中 set和线性结构 线性结构的查询时间复杂度是O(n)，即随着数据规模的增大而增加耗时 set、dict等结构，内部使用hash值作为key，时间复杂度可以做到O(1)，查询时间和数据规模无关 可hash 数值型int、float、complex 布尔型True、False 字符串string、bytes tuple None 以上都是不可变类型，成为可哈希类型，hashable set的元素必须是可hash的 字典(dict) key-value键值对的数据的集合 可变的、无序的、key不可重复 字典dict定义、初始化 d = dict() 或 d= {} dict(**kwargs)使用name=value对初始化一个字典 dict(iterable,**kwarg)使用可迭代对象和name=value对构造字典，不过可迭代对象的元素必须是一个二元结构 d = dict(((1,’a’),(2,’b’)))或者d = dict(([1,’a’],[2,’b’])) dict(mapping,**kwarg)使用一个字典构建另一个字典 d = {‘a’:10,’b’:20,’c’:None,’d’:[123]} 类方法dict.fromkeys(iterable,value) d = dict.fromkeys(range(5)) d = dict.fromkeys(range(5),0) 字典元素的访问 d[key] 返回key对应的值value key不存在抛出KeyError异常 get(key[,default]) 返回key对应的值value key不存在返回缺省值，如果没有设置缺省值就返回None setdefault(key[,default]) 返回key对应的值value key不存在，添加kv对，value为default，并返回default，如果default没有设置，缺省为Nome 字典增加和修改 d[key] = value 将key对应的值修改为value key不存在则添加新的kv对 update([other]) -&gt; None 使用另外一个字典的kv对更新本字典 key不存在，则添加 key存在，覆盖已经存在的key对应的值 就地修改 eg: d.update(red=1) d.update((&apos;red&apos;,2),) d.update({&apos;red&apos;:1}) 字典删除 pop(key[,default]) key存在，移除，并返回它的key key不存在，返回给定的default default未设置，key不存在则抛出KeyError异常 popitem() 移除并返回一个任意的键值对 字典为empty，抛出KeyError异常 clear 清空字典 del语句 del实际上删除的是名称，而不是对象 In [9]: a Out[9]: True In [10]: b Out[10]: [6] In [11]: d Out[11]: {&apos;a&apos;: 1, &apos;b&apos;: [6], &apos;c&apos;: [1, 3, 5]} In [12]: del a In [13]: a ---------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-13-3f786850e387&gt; in &lt;module&gt; ----&gt; 1 a NameError: name &apos;a&apos; is not defined In [14]: del d[&apos;c&apos;] In [15]: d Out[15]: {&apos;a&apos;: 1, &apos;b&apos;: [6]} In [16]: del b[0] In [17]: d Out[17]: {&apos;a&apos;: 1, &apos;b&apos;: []} In [18]: b Out[18]: [] In [19]: c = b In [20]: del c In [21]: c ---------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-21-2b66fd261ee5&gt; in &lt;module&gt; ----&gt; 1 c NameError: name &apos;c&apos; is not defined In [22]: del b In [23]: b ---------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-23-89e6c98d9288&gt; in &lt;module&gt; ----&gt; 1 b NameError: name &apos;b&apos; is not defined In [24]: b = d[&apos;b&apos;] In [25]: b Out[25]: [] 字典的key key的要求和set的元素要求移至 hashable可哈希开才可以作为key 字典遍历 for … in dict 遍历item，即kv对&gt; for item in d.items(): &gt; print(item) &gt; for k,v in d.items(): &gt; print(k,v) 总结 python3中，keys、values、items方法返回一个类似一个生成器的可迭代对象，不会把函数的返回结果复制到内存中 python2中，上面的方法会返回一个新的列表，占据新的内存空间。所以python2建议使用iterkeys、itervalues、iteritems版本，返回一个迭代器，而不是一个copy]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础语法]]></title>
    <url>%2F2019%2F04%2F11%2FPython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基础语法注释 Python中单行注释以 # 开头 实例如下: #第一个注释 print (&quot;Hello, Python!&quot;) # 第二个注释 执行以上代码，输出结果为： Hello, Python! 数字 int (整数), python3.0+中不区分（long和int） bool (布尔), 2个值 True、False。 float (浮点数), 如 1.23、-0.12 1.46e9等价与1.46*10⁹ complex (复数), 如 1 + 2j 字符串 使用’ “单双引号引用的字符的序列 ‘’’ “””单双三引号，可以跨行使用、可在其中自由的使用单双引号 在字符串前面加上r或R前缀，表示该字符不做特殊处理,实例如下： print(&apos;hello\nTao&apos;) # 使用反斜杠(\)+n转义特殊字符 print(r&apos;hello\nTao&apos;) # 在字符串前面添加一个 r，表示原始字符串，不会发生转义 输出结果如下： hello Tao hello\nTao 转义序列 \\ \t \r \n \’ \” 前缀r，把里面的所有字符当普通字符对待 缩进 未使用C语言的花括号，而是采用缩进的方式表示层次关系 约定使用4个空格缩进（可自定义） 续行 在行尾使用反斜杠（\），例如： 如果使用各种括号，认为括号内是一个整体，内部跨行不用\ 标识符 1、一个名字，用来指代一个值 2、只能由字母、下划线和数字组成 3、只能以字母或下划线开头（不建议使用下划线（_）开头） 4、不能使python的关键字，例如def、class等就不能作为标识符 5、Python大小写敏感 常量 一旦赋值就不能改变值得标识符 python中无法定义常量 字面常量 一个单独的量，如45、”abc”、’41561321.135e-8’ 变量 赋值后，可以改变值得标识符 运算符（Operator）算数运算符 + - * 、 % ** 自然除/结果是浮点数，整除//是整数。例子： print(6/3) print(6//3) 输出结果如下： 2.0 2 位运算符 &amp; | ~ ^ &lt;&lt; &gt;&gt; 常用方式：乘除2的倍数，32 // 4想当于32 &gt;&gt; 2 比较运算符 == != &lt; &gt; &lt;= &gt;= 返回值通常是一个bool值 逻辑运算符 与或非 and or not 短路运算符 and如果第一个表达式为False，后面就没必要计算了，这个逻 辑表达式一定是False or如果第一个表达式是True，后面也没必要计算了，这个逻辑 表达式一定是True 赋值运算符 a = 10 += -= *= /= %=等 x=y=z=10 成员运算符 in、not in 身份运算符 is、is not 表达式有数字、、符号、括号、变量等组合而成 算数表达式 逻辑表达式 赋值表达式Python中，赋值即定义，如果一个变量已经定义，赋值相当于重新定义 单分支结构if语句 if condition: 代码块condition必须是一个bool类型，这个地方有一个隐式转换bool(condition)例子： if 1 &lt; 2: print(&quot;1比2小&quot;) 代码块 类似于if语句的冒号后面的一个语句块 在if、for、def、class等中 多分支结构 if…elif…else语句if condition1: 代码块1elif condition2: 代码块2elif condition3: 代码块3……else： 代码块n 例子： score = 85 if score &gt;= 90: print(&apos;A&apos;) elif score &gt;=60: print(&apos;B&apos;) else: print(&apos;C&apos;) 分支嵌套 嵌套结构，可以是分支、循环的嵌套，可以是互相嵌套多层 例子： score = 85 if score &lt;0: print(&apos;error&apos;) else: if score &gt;= 90: print(&apos;A&apos;) elif score &gt;=60: print(&apos;B&apos;) else: print(&apos;C&apos;) 循环——while语句语法 while condition: block 当条件满足即condition为True时，进入循环体，执行block 例子： i = 5 while i: print(i) i -= 1 输出结构如下： 5 4 3 2 1 循环语句——for语句语法 for element in iteratable: block 当可迭代对象中由元素可以迭代，进入循环体，执行block，常与range函数使用 举例：打印1~10 for i in range(10): print(i+1) 输出结果如下： 1 2 3 4 5 6 7 8 9 10 循环语句——continue语句 中断当前循环的当次执行，继续下一次循环 举例：计算10以内的偶数(for循环) for i in range(10): if i%2 !=0: continue print(i,end=&quot;\t&quot;) 结果如下： 0 2 4 6 8 循环语句——else子语句语法 while condition: block else: block for element in iteratable: block else: block 如果循环正常的结束，就执行else语句；如果使用break终止，else子句不会执行]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令及相关参数]]></title>
    <url>%2F2017%2F12%2F21%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[线上查询及帮助命令man适用于一般命令，查看非内置命令的帮助。 --help适用于一般命令，查看非内置命令的帮助。 help适用于内置命令，查看内置命令的帮助。 文件和目录操作命令lslist(列表) 列表目录或文件-l(long) 长格式-d(directorys) 查看目录-p 给目录结尾加斜线（/）-F 给不同目录结尾加不同标识-a(all) 显示所有文件（包括隐藏文件）-t 按修改时间排序-r 反转排序，倒序-i 查看inode节点-h 人类可读--color=auto 显示颜色--time-style=long-iso 格式化时间 例子： 列根(/) 目录下的文件或目录–&gt;ls / cdchange directorys 改变目录路径 例子：cd /etc cpcopy 拷贝文件或目录，默认不能拷贝目录-r(recursive) 递归，用于复制目录-p 连同档案的文件属性一起复制过去，而非使用默认属性-d 若源文件为链接文件（link file），则复制链接文件属性而非档案属性-a 相当于-pdr，复制文件保持文件所有属性 例子:cp /etc/ssh/sshd_config{,.ori} 等价于 cp /etc/ssh/sshd_config /etc/ssh/sshd_config.ori find查找-type 文件类型（f(file),d(directory),c(character),b(block)，s(socket),l(link)）-name “文件名” 按文件名称查找文件！ 取反-maxdepth 查找深度-mtime 时间 按修改时间查找，时间数字（+7 七天之前，7 第七天，－7 最近七天） mkdir make directorys 创建目录-p 递归创建目录，一般第一级目录不存在时用-P，否则报错 例子：在根（/）下创建data目录–&gt;mkdir /data mvmove 移动或重命名文件 pwdprint work directory 打印工作目录（显示当前所在路径） renameRename files 重命名文件 例子: rmremove 删除文件和目录-r(recursive) 递归删除目录及其内容-f（force） 强制 touch创建或更新文件的时间戳，如果文件不存在，就建立新文件，如果存在，就改变文件的访问时间atime等事件戳信息。 tree大树的意思，显示目录树-L（layer） 层数-d 显示目录 basename 例子: dirname跟basename相反 例子: chattr改变文件的扩展属性a 只能追加内容i 文件加锁 lsattr显示文件的扩展属性 file查看文件的类型 md5sum计算和校验文件的md5值 查看文件及内容处理命令cat查看文件内容-n 显示行号-b 显示非空行的行号-E 在每一行末尾显示$号-T 区分tab键和空格 tac反向显示文件内容 more按页一次一屏显示，回车一次一行，空格一次一屏，按b可以一次回退一屏。-= 显示光标所在行行号 less分页查看文件内容，回车一次一行，空格一次一屏，按b可以一次回退一屏。-N 显示行号 head头，头部 读取文件的前n行，默认前十行 例子： head -2 test.txt tail尾，尾巴 读取文件的后n行，默认最后十行 例子： tail -2 test.txt cut切割 取列-d分隔符-f取列 例子： split按照指定的行数或大小分割文件-l 指定行数例子：split -l 10 /etc/inittab new_ -a 指定生成文件后缀长度 例子：split -l 10 -a 3 /etc/inittab new1_ -d 使用数字后缀 例子：split -l 10 -d /etc/inittab new_ -b 指定分割大小 例子split -b 200K /etc/inittab paste合并两个文件内容-d 指定分隔符 例子：paste -d : a b sort默认按照第一列、ASCII码排序，升序， 从小到大-n 按照数值排序-r 倒序，从大到小-k 指定区域-t 指定分隔符例子： sort –t: -k2 oldboy.txt uniq去除重复行 wc统计文件行数 单词数 字节数-l(lines) 显示总行数-L 显示最大行的长度 iconv转换文件的编码格式 dos2unix把windows文件格式转换成linux的文件格式windows的换行符是：\r\nlinux的换行符：\n diff逐行比较文件和目录内的文件不同a 增加c 改变d 删除 vimdiff可视化对比工具 rev反向输出文件内容 grep/egrepLinux三剑客老三……过滤需要的内容-v 后接要排除的内容 例子：grep oldboy test.txt -A 除了显示匹配的一行之外，并显示该行的后num行-B 除了显示匹配的一行之外，并显示该行的前num行-C 除了显示匹配的一行之外，并显示该行的前后num行--color=auto 对过滤的字符串加颜色-E 扩展的grep，即egrep-n 对匹配的内容打印行号-i 不区分大小写-o 按单词搜索，相当于\b join按两个文件的相同字段合并 trtranslate or delete characters(替换或删除字符) 例子： vi/vim命令行文本编辑器 文件压缩及解压缩命令tar打包压缩（z c v f j x X N p P C --exclude） unzip解压文件 gzipgzip压缩工具 zip压缩工具 信息显示命令uname显示操作系统相关的命令 hostname显示或者设置当前系统的主机名 dmesg显示开机信息，可以查看系统故障信息 uptime显示系统运行时间及负载 stat显示文件和文件系统状态（查看文件属性） du查看文件和目录大小-sh df查看磁盘信息–I–h–T 文件类型 top实时显示系统资源使用情况 free查看系统内存 date显示与设置系统时间-d 显示字符串所指的日期与时间。字符串前后必须加上双引号-s 根据字符串来设置日期与时间。字符串前后必须加上双引号%Y 表示年%m 表示月%d 表示天%H 表示小时（表示的时间是00-23）%M 表示分钟%S 表示秒%s（表示unix时间戳的秒数）例子：[root@zht ~]# date +’%Y-%m-%d %H:%M:%S’2017-12-21 22:16:12 cal查看日历等时间信息 搜索文件命令which查看二进制命令所在路径（从PATH变量所在的路径查找） find从磁盘遍历查找文件或目录-type 文件类型（f(file),d(directory),c(character),b(block)，s(socket),l(link)）-name “文件名” 按文件名称查找文件！ 取反-maxdepth 查找深度-mtime 时间 按修改时间查找，时间数字（+7 七天之前，7 第七天，－7 最近七天） whereis查看命令的帮助、源代码-b 二进制 locate通过名字查找文件这个命令只能查updatedb库里内容，locate从/var/lib/mlocate/mlocate.db查找路径 用户管理命令useradd添加用户用法：useradd 用户名-s 指定用户登入后所使用的shell (-s /sbin/nologin)–u 指定uid-c 注释-d (指定家目录)-G 指定属于多个组-m 创建家目录-g 指定属于的组–e 指定过期时间-M 不创建家目录 usermod更改用户属性 userdel删除用户-r 删除家目录 groupadd添加组-g 组id groupdel删除组 passwd为用户设置或修改密码--stdin 非交互式更改密码例子：echo “123456”|passwd –stdin oldboy chage设置或修改用户密码有效期限-l(list)列表-E将用户过期时间设置为“过期日期” id查看用户和组信息 su切换用户身份 加载环境变量-c 以指定用户切换身份visudo通过visudo编辑/etc/sudoers，可以检查语法sudo可以让普通用户拥有root权限去执行命令sudo的配置文件为/etc/sudoers基础网络操作命令telnet使用TELNET协议远程登陆ssh使用SSH加密协议远程登陆scp远程拷贝文件或目录的命令 -P (port) 接端口，默认22端口时可以省略-P22 -r 递归，表示拷贝目录 -p 表示再拷贝前后保持文件或目录的属性 -l (limit) 限制速度 wget命令行下载命令-q 安静的-O 指定文件名ping测试主机之间网络的连通性（使用ICMP协议，是TCP/IP协议族的一个子协议）route显示和设置linux系统的路由表ifconfig查看、配置、启用或禁用网落接口的命令ifup启动网卡ifdown关闭网卡netstat查看网络状态-lntup-a查看所有例子: ss查看网络状态 深入网络操作命令nmap网络扫描命令 lsoflist open files 列举操作系统中已经被打开的文件 例子： mail发送和接收邮件 mutt邮件管理命令 nslookup交互式查询互联网DNS服务器的命令 dig查找DNS解析过程 host查询DNS命令 traceroute追踪数据传输路由状况 tcpdum命令行的抓包工具 有关磁盘和文件系统的命令mount挂载文件系统-t type–o umount卸载文件系统-lF 强制卸载 fsck检查并修复linux文件系统 dd转换和拷贝文件（convert and copy a file） dumpe2fs查看ext文件系统信息 dumpext文件系统备份工具 fdisk 磁盘分区工具（&lt;2T）-l 列表 parted分区工具（常用大于2T） mkfs格式化-b block–I inode用法：mkfs.ext4等价于mkfs –t ext4 partprobe让分区表的修改变化通知内核 e2fsck检查ext类型文件系统 mkswap格式化swap分区 swapon启用交换分区 swapoff关闭交换分区 sync将内存缓冲区内容的数据写入磁盘 resize2fs调整ext类型文件系统大小 系统权限及用户授权相关命令chmod更改及设置文件对应权限 chown更改及设置文件对应的用户和组 chgrp更改文件用户组 umask控制文件默认权限默认情况下的umask值是022(可以用umask命令查看），此时建立的文件默认权限是644(6-0,6-2,6-2)，建立的目录的默认权限是755(7-0,7-2,7-2) ###查看系统用户登录信息的命令 whoami显示当前有效的用户名称，相当于执行id -un命令 who显示目前登陆系统的用户信息 w显示已经登陆系统的用户列表，并显示用户正在执行的指令 last显示用户登陆的历史 lastlog所有计算机用户最近的登陆情况 finger查找并显示用户信息 内置命令及其他echo是一个打印输出内容的一个常用命令，配合“&gt;”或“&gt;&gt;”可以为文件覆盖或追加内容。-n 不换行输出-e 可用转义字符（\n 回车， \t， Tab键）“&gt;”意思为重定向，会清楚文件里所有以前数据，“&gt;&gt;”为内容追加，只在文件尾部追加需要的内容，还有一个比较复杂不常用的类似命令printf. printf将结果格式化输出到标准输出 rpm管理rpm包的命令-q query-a all-f file查询一个命令属于哪个包[root@m01 ~]# rpm -qf /bin/lscoreutils-8.4-43.el6.x86_64知识点：-q or -query-f, --file query/verify package(s) owning file[root@m01 ~]# rpm -qa coreutilscoreutils-8.4-43.el6.x86_64知识点：-a, --all query/verify all packages卸载：rpm –e –nodeps 包名-e, --erase=+ erase (uninstall) package--nodeps don’t verify package dependencies--force short hand for --replacepkgs –replacefiles 安装：rpm -ivh 包名升级：rpm -Uvh 包名-i, --install install package(s)-h, --hash print hash marks as package installs (good with -v)-v, --verbose provide more detailed output-U, --upgrade=+ upgrade package(s)查看包里有哪些文件[root@m01 ~]# rpm -ql tree/usr/bin/tree/usr/share/doc/tree-1.5.3/usr/share/doc/tree-1.5.3/LICENSE/usr/share/doc/tree-1.5.3/README/usr/share/man/man1/tree.1.gz知识点：-l, --list list files in package yum自动化简单化地管理rpm包的命令 watch周期性执行程序，打印到目录，默认2秒-n 制定秒 alias查看和设置别名设置别名： alias cp=’cp -i’ unalias取消已有别名 例子：unalias mv–&gt; 取消mv别名 clear清屏，相当于快捷键Ctrl+l history查看及清理历史记录 -c 清空所有 -d 删除指定历史记录 eject弹出光驱 time计算命令执行时间 nc功能强大的网络工具 nl 显示行号 （number lines） xargs从标准输入（管道过stdin、输入重定向）获取数据，并将数据转换成命令行的参数-n 数字 分组 例子： exec调用并执行指定的命令 unset删除变量或函数 export设置或显示环境变量 type用于判断另外一个命令是否是内置命令 bc命令行科学计算器 rsync文件复制工具-v --verbose 详细模式输出，传输时的进度等信息-z --compress 传输时进行压缩以提高传输效率--compress-level=NUM 可按级别压缩-a --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rtopgDl-r --recursive 对子目录以递归模式，即目录下的所有目录都同样输出，注意是小写r-t --times 保持文件时间信息-o --owner 保持文件属主信息-p --perms 保持文件权限-g --group 保持文件属组信息-P --progress 显示同步的过程及传输时的进度等信息-D --devices 保持设备文件信息-l --links 保持软连接-e --rsh=COMMAND 使用的信道协议，指定替代rsh的shell程序。例如：ssh--exclude=PATTERN 指定排除不需要传输的文件模式（和tar参数一样）--exclude-from=file（文件名所在的目录文件）（和tar参数一样）--bwlimit=RATE limit socket I/O bandwidth--delete 让目标目录SRC和源目录数据DST一致 系统管理与性能监视命令chkconfig设置开机自启动的命令--list 查看自启动服务--level levels 例子：chkconfig –level levels sshd off(on) levels：运行级别 chkconfig –list 显示所有服务 chkconfig –list sshd 查看指定服务是否开机自启动。 vmstat虚拟内存统计 mpstat显示各个可用CPU的状态 iostat统计系统IO sar全面地获取系统的CPU、运行队列、磁盘I/O、分页（交换区）、内存、CPU中断和网络等性能数据 ipcs用于报告Linux中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息 ipcrm用来删除一个或更多的消息队列、信号量集或者共享内存标识 strace用于诊断、调试Linux用户空间追踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。 ltrace命令会跟踪进程的库函数调用，它会显示出那个库函数被调用 关机/重启/注销和查看系统信息的命令shutdown关机 halt关机 poweroff关闭电源 logout退出当前登陆的shell，相当于快捷键Ctrl+d exit退出当前登陆的shell，相当于快捷键Ctrl+d 进程管理相关命令bg讲一个在后台暂停的命令，变成继续执行（在后台执行） fg将后台中的命令调至前台继续运行 jobs查看当前有多少在后天运行的命令 kill终止进程 killall通过进程名终止进程 pkill通过进程名终止进程 crontab定时任务命令。维护用户的crontab配置文件。-e（edit）-l（list）-r（erase） 如：xufqin用户创建一个新的crontab配置文件。$ crontab –e at设置指定时间执行的指定的命令。（只执行一次）–f 文件名（file）-l（list）-d（delete） 例子：在3分钟后向文件/tmp/test/test.txt写入信息“Hello”。$at now + 3 minutesat&gt;echo “Hello” &gt;&gt; /tmp/test.txt然后按Ctrl+D保存 ps显示进程的状态。无选项时显示当前用户在当前终端启动的进程-a（all）-e-l（list）-u（user）-x-t-f pstree树形显示进程 nice指定将启动的进程的优先级。不指定优先级值时，将优先级设置为10 例子：#nice -5 ftp启动ftp程序，其优先级为5 renice修改运行中的进程的优先级，设定指定用户或组群的进程优先级-p 进程号-u 用户名-g 组群号 例子：将xufqin用户的进程优先级调高为-5。 #renice -5 -u xufqin nohup忽略挂起信号运行指定的命令 pgrep查找匹配条件的进程 runlevel查看当前系统的运行级别 init切换运行级别，后接数字（0-6） service启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。]]></content>
      <categories>
        <category>Linux学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS6.8最小化安装]]></title>
    <url>%2F2017%2F12%2F08%2FCentOS6.8%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装CentOS6.8操作系统的过程加载完CentOS6.8的ISO镜像文件后，开启/重启计算机或虚拟机，此时系统会进行自检，自检完毕后就会出现如图1-1所示的安装操作系统时的引导界面。 图1-1提示：如果是在虚拟机上安装CentOS系统，需要进入虚拟机界面操作，如果需要退出虚拟机界面，可按快捷组合键Ctrl+Alt。 选择系统引导方式在图1-1所示的引导界面中，可以看到共有五种引导方式，其中第一种（新服务器安装或已有服务器升级）和第三种（系统故障恢复）引导方式比较有用，其他几个选择基本用途不大，可以忽略。此处选择第一项“Install or upgrade an existing system”，即默认选项，然后按Enter（回车）键进入图形安装界面。 检查安装光盘介质确定引导方式后，进入如图1-2所示的界面，如果需要检查光盘介质，选择“OK”，否则按Tab键选择“Skip”，这里直接按Tab选择“Skip”，然后按Enter键 继续 图1-2 进入安装下一步界面忽略光盘介质检查后，进入如图1-3所示的界面。然后单击“NEXT”键继续。 图1-3 安装过程语言选择进入如图1-4所示的界面后，可对安装过程语言进行选择，这里保留默认选项“English”即可，然后单机“Next”继续。 图1-4 选择键盘布局进入如图1-5所示的选择键盘布局界面后，选择保留默认选项“U.S.English”，单击“NEXT”继续 图1-5 选择合理的物理设备进入如图1-6所示的界面后，会看到两个选项，如果是普通服务器，默认选择第一个“Basic Storage Devices”即可，第二个是用于特殊存储设备的，例如SANs（ISCSI）等。这里保留默认选项即可，然后单击“NEXT”继续。 图1-6 初始化硬盘提示进入如图1-7所示的界面后，会看到相应的警告信息，单击 “Yes,discard any data” 继续。 图1-7 初始化主机名现在进入如图1-8界面，在图1-8中，左上角的“Hostname”表示配置主机名，在右边的边框里，会有默认的主机名，将其清空，然后设置你自己的主机名，这里用zht作为主机名。 图1-8 系统时钟及时区设置在图1-9所示的界面中，选择“Asia/Shanghai”，然后取消“System clock uses UTC” 前的对勾，然后单击”Next”继续。 图1-9 设置超级用户root口令在如图1-10界面中，输入两次root用户的口令，然后单击右下角“Next”继续。如果密码过于简单会出现如图1-11所示的提示，可以选择单击“Use Anyway”强制设置。 图1-10 图1-11 磁盘分区选择与磁盘分区配置过程选择系统安装磁盘空间类型经过以上步骤之后，会进入如图2-1所示的界面。 图2-1 在这里我们选择“Create Custom Layout”自定义磁盘分区，然后会进入如图2-2所示的界面中。 图2-2 自行定制磁盘分区在这里，先选中磁盘下的“Free 10236”这一行，然后点击“Create”按钮，开始创建磁盘分区，进入如图2-3所示的界面 图2-3 选择创建标准分区（Standard Partition）后，单击页面右下角的“Create”按钮，进入到如图2-4所示的界面，然后按照图2-4所示配置第一个分区（boot分区）即可，配置完成后点击“OK”即可。 图2-4 接着继续创建swap交换分区，配置如图2-5界面所示即可，然后点击“OK” 图2-5 最后一步创建根（/）分区，再次进入“Add Partition”操作界面后，按照图2-6配置根（/）分区的设置即可。 图2-6由于根（/）分区是最后一个分区，因此就把剩余的空间都给它了 ! 创建完根分区后，最终的结果如图2-7所示，然后点击“Next”继续。此时，系统需要对分区进行格式化，而且会出现格式化警告窗口，这时，单击“Format（格式化）” 继续即可，这个过程可能还会提示写入分区表，在写入配置但磁盘的窗口中，单机“write changes to disk”继续。 图2-7 CentOS6.8系统安装包组的选择与配置过程启动引导设备的配置分区格式化格式化后，会进入如图2-8所示的界面，系统默认使用FRUB作为启动加载器，引导程序默认在MBR下，按“Next”继续。 图2-8勾选图中的“Use a boot loader password”可为GRUB引导菜单设置密码，防止别人接触到计算机破解root密码。 系统安装类型选择击自定义额外包组进入图2-9所示的界面后，勾选“Miniml”和“Customize now（立即自定义）”然后单击“Next”继续即可，然后会进入自定义安装包选择界面。图2-9 在自定义安装包选择界面中，按照图2-10和图2-11所示配置即可。然后点击“Next”继续即可开始安装系统了！ 图2-10 图2-11 安装结束系统安装结束后，出现的界面如图2-12所示，此时单击“Reboot”键即可重启系统。 图2-12 以上内容参考自著名讲师老男孩的著作《跟老男孩学Linux运维web集群实战》一书！！]]></content>
      <categories>
        <category>Linux学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
